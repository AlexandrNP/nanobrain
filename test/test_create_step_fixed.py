#!/usr/bin/env python3
"""
Test script for creating a step with fix for the None error in await.
"""

import os
import sys
import asyncio
import traceback
from src.ExecutorFunc import ExecutorFunc
from builder.WorkflowSteps import CreateWorkflow, CreateStep

# Set testing mode to use mock models
os.environ["NANOBRAIN_TESTING"] = "1"

# Mock executor that returns a fixed string instead of using an LLM
class MockExecutor(ExecutorFunc):
    async def execute_async(self, runnable):
        if isinstance(runnable, list) and len(runnable) > 0:
            for msg in runnable:
                if isinstance(msg, dict) and msg.get("role") == "user":
                    # This is the code that would be generated by the LLM
                    return '''```python
from src.Step import Step

class StepTestFixed(Step):
    """
    TestFixed step - for testing fixed step creation.
    
    Biological analogy: Neuron processing fixed data.
    Justification: Like how neurons transform inputs in predictable ways,
    this step processes data in a fixed manner.
    """
    
    def __init__(self, executor, name="StepTestFixed", **kwargs):
        """Initialize the step."""
        super().__init__(executor=executor, name=name, **kwargs)
    
    async def process(self, data_dict):
        """Process the input data."""
        # Create a copy of the input data
        result = data_dict.copy() if data_dict else {}
        result['processed_by'] = self.__class__.__name__
        return result
```'''
        
        return f"Mock response for: {runnable}"

async def main():
    try:
        print("1. Setting up testing environment...")
        # Import after setting the testing mode
        from builder.NanoBrainBuilder import NanoBrainBuilder
        
        print("2. Creating builder...")
        builder = NanoBrainBuilder()
        
        # Replace the executor with our mock
        print("3. Creating mock executor...")
        mock_executor = MockExecutor()
        mock_executor.base_executor.runnable_types.add('str')
        mock_executor.base_executor.runnable_types.add('list')
        mock_executor.base_executor.runnable_types.add('dict')
        builder.executor = mock_executor
        
        print("4. Creating workflow 'test_workflow_fixed'...")
        workflow_result = await CreateWorkflow.create_workflow(builder, "test_workflow_fixed")
        print(f"Workflow result: {workflow_result}")
        
        if workflow_result.get("success", False):
            workflow_path = os.path.join(builder.workflows_dir, "test_workflow_fixed")
            
            print(f"5. Setting '{workflow_path}' as current workflow...")
            builder.push_workflow(workflow_path)
            
            print("6. Creating step 'TestFixed'...")
            step_result = await CreateStep.execute(builder, "TestFixed", "Step", "A fixed test step")
            print(f"Step result: {step_result}")
        else:
            print(f"Failed to create workflow: {workflow_result}")
    
    except Exception as e:
        print(f"Error: {e}")
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main()) 