#!/usr/bin/env python3
"""
Minimal test for creating step files.
"""

import os
import asyncio
import shutil
from pathlib import Path

async def create_step(workflow_name: str, step_name: str, description: str = None):
    """Create a step directly without using NanoBrainBuilder."""
    print(f"Creating step {step_name} in workflow {workflow_name}...")
    
    # Get the workflow path
    workflows_dir = "workflows"
    workflow_path = os.path.join(workflows_dir, workflow_name)
    
    # Create workflow directory if it doesn't exist
    if not os.path.exists(workflow_path):
        os.makedirs(workflow_path, exist_ok=True)
        os.makedirs(os.path.join(workflow_path, "src"), exist_ok=True)
        os.makedirs(os.path.join(workflow_path, "config"), exist_ok=True)
        os.makedirs(os.path.join(workflow_path, "test"), exist_ok=True)
        print(f"Created workflow directory: {workflow_path}")
    
    # Format the step name in CamelCase
    step_class_name = f"Step{step_name}"
    
    # Create the step directory
    step_dir = os.path.join(workflow_path, 'src', step_class_name)
    
    # Check if the directory already exists
    if os.path.exists(step_dir):
        print(f"Removing existing step directory: {step_dir}")
        shutil.rmtree(step_dir)
    
    # Create the directory structure
    os.makedirs(step_dir, exist_ok=True)
    os.makedirs(os.path.join(step_dir, 'config'), exist_ok=True)
    
    # Create the step class file
    step_class_content = f'''#!/usr/bin/env python3
"""
{step_class_name} - A custom step for the NanoBrain framework.

{description or "This step was generated by the test script."}
"""

from src.Step import Step

class {step_class_name}(Step):
    """
    {step_class_name} - A custom step for the NanoBrain framework.
    
    Biological analogy: Neuron processing specific data.
    Justification: Like how specialized neurons transform inputs in specific ways,
    this step transforms input data in a specific manner.
    """
    
    def __init__(self, executor, name="{step_class_name}", **kwargs):
        """
        Initialize the {step_class_name}.
        
        Args:
            executor: Executor for running the step
            name: Name of the step (default: "{step_class_name}")
            **kwargs: Additional arguments to pass to the parent class
        """
        super().__init__(executor=executor, name=name, **kwargs)
    
    async def process(self, data_dict):
        """
        Process the input data.
        
        Args:
            data_dict: Dictionary containing the input data
            
        Returns:
            The processed data
        """
        # Create a copy of the input data
        result = data_dict.copy() if isinstance(data_dict, dict) else {{"input": data_dict}}
        
        # Add a processed flag
        result['processed_by'] = "{step_class_name}"
        
        return result
'''
    
    # Create configuration file
    config_content = f'''# Configuration for {step_class_name}
defaults:
  class: workflows.{workflow_name}.src.{step_class_name}.{step_class_name}
  name: {step_class_name}
  executor: ExecutorFunc

metadata:
  description: "{description or 'A custom step for the NanoBrain framework'}"
  author: "Test Script"
  version: "0.1.0"
  biological_analogy: "Neural circuit processing specific information"
  justification: "Like how dedicated neural circuits process specific types of information, this step performs a specific processing task in the workflow."

validation:
  required:
    - name
    - executor
  optional:
    - debug_mode

examples:
  - name: "Example{step_class_name}"
    executor: ExecutorFunc
    debug_mode: true
'''
    
    # Create test file
    test_content = f'''#!/usr/bin/env python3
"""
Tests for {step_class_name}.

This test file was generated by the test script.
"""

import unittest
import asyncio
from unittest.mock import MagicMock, AsyncMock

# Add project root to path
import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../..")))
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

# Import the step class
from workflows.{workflow_name}.src.{step_class_name}.{step_class_name} import {step_class_name}

class Test{step_class_name}(unittest.TestCase):
    """Test suite for {step_class_name}."""
    
    def setUp(self):
        """Set up test fixtures."""
        # Create a mock executor
        self.mock_executor = MagicMock()
        self.mock_executor.can_execute = MagicMock(return_value=True)
        self.mock_executor.execute = AsyncMock(return_value={{"success": True, "result": "test_result"}})
        
        # Create the step
        self.step = {step_class_name}(executor=self.mock_executor, name="Test{step_class_name}")
    
    def tearDown(self):
        """Clean up after tests."""
        self.step = None
    
    def run_async(self, coroutine):
        """Run coroutine in the event loop."""
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(coroutine)
    
    def test_process(self):
        """Test the process method."""
        # Create test data
        test_data = {{"input": "test"}}
        
        # Process the data
        result = self.run_async(self.step.process(test_data))
        
        # Verify the result
        self.assertIsNotNone(result)
        self.assertIn("processed_by", result)
        self.assertEqual(result["processed_by"], "{step_class_name}")

if __name__ == '__main__':
    unittest.main()
'''
    
    # Create init file
    init_content = f'''from .{step_class_name} import {step_class_name}

__all__ = ['{step_class_name}']
'''
    
    # Write the files
    with open(os.path.join(step_dir, f"{step_class_name}.py"), "w") as f:
        f.write(step_class_content)
    
    with open(os.path.join(step_dir, "config", f"{step_class_name}.yml"), "w") as f:
        f.write(config_content)
    
    with open(os.path.join(workflow_path, "test", f"test_{step_class_name}.py"), "w") as f:
        f.write(test_content)
    
    with open(os.path.join(step_dir, "__init__.py"), "w") as f:
        f.write(init_content)
    
    # Copy the configuration file to the workflow config directory
    workflow_config_file = os.path.join(workflow_path, "config", f"{step_class_name}.yml")
    with open(workflow_config_file, "w") as f:
        f.write(config_content)
    
    print(f"\n‚úÖ Step creation completed! Summary:")
    print(f"üìÅ Step directory: {step_dir}")
    print(f"üìÑ Step class: {os.path.join(step_dir, f'{step_class_name}.py')}")
    print(f"üìÑ Config file: {os.path.join(step_dir, 'config', f'{step_class_name}.yml')}")
    print(f"üìÑ Test file: {os.path.join(workflow_path, 'test', f'test_{step_class_name}.py')}")
    print(f"üìÑ Workflow config: {os.path.join(workflow_path, 'config', f'{step_class_name}.yml')}")
    
    return {
        "success": True,
        "message": f"Created step {step_class_name} at {step_dir}",
        "step_dir": step_dir,
        "step_class_name": step_class_name
    }

async def main():
    await create_step("test_workflow_minimal", "MinimalTest", "A test step created without NanoBrainBuilder")

if __name__ == "__main__":
    asyncio.run(main()) 